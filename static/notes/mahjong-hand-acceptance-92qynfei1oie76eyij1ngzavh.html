<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mahjong Hand Acceptance</title>

    <!-- browser setup -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">

    <!-- page meta information -->
    <meta name="description" content="Mahjong Hand Acceptance">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="gtoolkit book">
    <meta property="og:title" content="Mahjong Hand Acceptance">
    <meta property="og:url" content="https://book.gtoolkit.com/mahjong-hand-acceptance-92qynfei1oie76eyij1ngzavh.html">
    <meta property="og:description" content="Mahjong Hand Acceptance">

    <!-- CSS styles -->
    <link rel="stylesheet" href="assets/vendor/awesomefonts/css/all.css">
    <link rel="stylesheet" href="assets/vendor/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/v2/src/css/lepiter-common.css">
    <link rel="stylesheet" href="assets/v2/src/css/lepiter-snippets.css">
    <link rel="stylesheet" href="assets/v2/src/css/vs.css">
</head>
<body>

    <div class="content">
        <div class="row le-row">

            <!-- side menu with header -->

            <div class="col-lg-3 le-nav-column">
                <div class="side-menu sticky-top navbar-expand-lg le-nav-scrollable le-nav-container">
                    <header class="navbar navbar-light bg-white sticky-top px-3 le-nav-footer">
                        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#le-nav-collapsable" arial-controls="le-nav-collapsable" arial-expanded="false" arial-label="Toggle navigation">
                            <i class="fas fa-bars">
                            </i>
                        </button>
                        <p class="le-logo">
                            <a class="le-logo-link" href="https://gtoolkit.com" alt="Glamorous Toolkit"><span class="le-logo-g">glamorous</span><span class="le-logo-t">toolkit</span></a> <span class="le-logo-version">v1.0.535</span>
                        </p>
                    </header>

                    <nav id="le-nav-collapsable" class="navbar-collapse collapse le-nav-root">

                        <!-- navigation start -->

                        <ul class="nav flex-column le-nav le-nav-level-0">  <li class="nav-item  le-nav-item le-nav-level-1">    <a class="nav-link le-nav-link le-nav-level-1" href="table-of-contents-2qzwdq1sjk7rkkm19wn9xo3xm.html">Table of Contents    </a>    <ul class="nav flex-column le-nav le-nav-level-1">      <li class="nav-item  le-nav-item le-nav-level-2">        <a class="nav-link le-nav-link le-nav-level-2" href="mahjong-ajc74mr0i1pgt8td5660dkhg5.html">Mahjong        </a>        <ul class="nav flex-column le-nav le-nav-level-2">          <li class="nav-item  le-nav-item le-nav-level-3">            <a class="nav-link le-nav-link le-nav-level-3" href="mahjong-tactics-1l41j2ln59fumi6gfkewcjimu.html">Mahjong Tactics            </a>          </li>          <li class="nav-item  le-nav-item le-nav-level-3">            <a class="nav-link le-nav-link le-nav-level-3" href="mahjong-algorithms-and-exploration-3ifqqrjnuly2xjmfreghzqayr.html">Mahjong Algorithms and Exploration            </a>            <ul class="nav flex-column le-nav le-nav-level-3">              <li class="nav-item  active le-nav-item le-nav-level-4">                <a class="nav-link le-nav-link le-nav-level-4 active" href="mahjong-hand-acceptance-92qynfei1oie76eyij1ngzavh.html">Mahjong Hand Acceptance                </a>              </li>            </ul>          </li>        </ul>      </li>    </ul>  </li></ul>

                        <!-- navigation end -->
                    </nav>
                </div>
            </div>

            <!-- main content -->

            <div class="col-lg-9 le-main-col">
                <div class="container min-height py-5 le-main-container">
                    <main>
                        <h1 class="le-main-title">Mahjong Hand Acceptance</h1>

                        <!-- page content start -->

                        <div class="snippet textual-snippet text-snippet paragraphWidth">  <h4> Figuring out an algorithm for hand acceptance  </h4></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>A way to think about what a hand accepts is by looking at hands and thinking what they accept and under what conditions do the waits change.  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbrc3z3r4o5z9wpmokqerv.png"/></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>More generally this hand accepts:  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbrdhz4ld7zyrsv7j1crx9.png"/></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We can sort of derive this value by breaking up the hand into various groups and potential groups.  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbr7m6mkco8iqgoclc3jjh.png"/></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We can see that the groups accept the following. The seperator shows what break accepts what  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbr8m0vdj9dkbpvsjihfys.png"/></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>This style of breaking up the hands seems to correspond with our intuition on what tiles this hand accepts.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The above example gives us a good intuition on how to tackle the problem. if we can somehow shuffle the tiles in our hand and try to make various kinds of groups with them, we will get our waits. Note that in creating these groups, if two tiles connect in a way, we have to group them together.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>With this criteria, I propose that we can achieve this by getting all permutations of the tils within the same kind, and creating some groups that know what they accept. The tiles sorted in front will get the groups first. Meaning that a permutation should lead us to all such hands.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h4> Programming a solution  </h4></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Since we are using GT to write this document let us get started by trying to get all permutations.  </p></div><div class="snippet textual-snippet code-snippet pharo-snippet fullWidth">  <pre class="no_bottom_margin">hand := '2345m' asMJHand  </pre></div><div class="snippet textual-snippet code-snippet pharo-snippet fullWidth">  <pre class="no_bottom_margin">permutations := Array	streamContents: [ :stream | hand tiles permutationsDo: [ :each | stream nextPut: each copy ] ]  </pre></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>this looks fairly decent for a start, let us try to break this into group which can accept hands.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>For this we will make a goup class which knows what hands it accepts: <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroup	instanceVariableNames: 'kind'	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h5> MJGroup  </h5></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The point of <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroup	instanceVariableNames: 'kind'	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span> is mainly to make a hand that knows what it needs to be considered a completed set.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>For our quick and dirty version we will simply make it a class that computes on the spot what tiles it accepts, and rejects any tiles outside of it's acceptance sphere.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Note that in the optimization section we will optimize this, so clicking on the methods may not reflect this simple design.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The main mehtods we have to make are:  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#accepts:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">accepts: tile	^ (tiles allSatisfy: [ :aTile | self predicate value: aTile value: tile ])		or: [ tiles isEmpty ]</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#add:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">add: tile	(self accepts: tile) ifFalse: [ ^ self ].	tiles addLast: tile.	tiles size = 2		ifTrue: [ ((tiles at: 1) sameAs: (tiles at: 2))				ifTrue: [ kind := 'triples' ]				ifFalse: [ kind := 'run' ] ].	^ self</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#with:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">with: aCollection	| instance |	instance := self new.	aCollection do: [ :tile | instance add: tile ].	^ instance</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#predicate</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">predicate	kind = 'run' ifTrue: [ ^ [ :v1 :v2 | v1 runsWith: v2 ] ].	kind = 'triples' ifTrue: [ ^ [ :v1 :v2 | v1 sameAs: v2 ] ].	^ [ :v1 :v2 | v1 combinesWith: v2 ]</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p><code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsTiles</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsTiles	| accepts |	tiles isEmpty ifTrue: [ ^ MJHand allTiles ].	accepts := OrderedCollection empty.	kind = 'run' ifTrue: [ self acceptsRunWith: accepts ].	kind = 'triples' | (tiles at: 1) isSpecial		ifTrue: [ self acceptsTripleWith: accepts ].	kind isNil &amp; (tiles at: 1) isSpecial not		ifTrue: [ self acceptsRunWith: accepts ].	^ MJHand with: accepts</code>    </span> this one was a bit annoying, but we will need it for groups later...  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>With some more minor sugar we can see our hand acceptance works.  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbr9xym5n81x5sltk4jot3.png"/></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>This isn't the most satisfying, let us make a view that can show us what the group accepts.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#visualizeAccepts:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">visualizeAccepts: view	| needs nodes |	needs := self acceptsTiles.	nodes := needs tiles copy.	nodes addLast: self.	tiles isEmpty		ifTrue: [ needs naturalLayout: view ]		ifFalse: [ MahjongExamples new				basicGraph: nodes				edges: (needs tiles collect: [ :tile | self -> tile ])				withView: view ].	^ view</code>    </span> this one was also a bit hairy but it's not too bad.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#visualizeAcceptsView:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">visualizeAcceptsView: aView	&lt;gtView>	self acceptsTiles tiles isEmpty ifTrue: [ ^ aView empty ].	^ aView mondrian		title: 'Accepts';		painting: [ :view | self visualizeAccepts: view ]</code>    </span> the view itself which is not bad.  </p></div><div>  <div class="snippet textual-snippet code-snippet pharo-snippet fullWidth">    <pre class="no_bottom_margin">simpleGroup	&lt;gtExample>	^ '5s' asMJGroup    </pre>  </div>  <figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbrdiccfjn844e06d8dlcs.png"/>  </figure></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>With the view done, we can now nicely inspect any group object and see what tiles it requires.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>A note on efficiency, the original algorithm of <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsTiles</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsTiles	| accepts |	tiles isEmpty ifTrue: [ ^ MJHand allTiles ].	accepts := OrderedCollection empty.	kind = 'run' ifTrue: [ self acceptsRunWith: accepts ].	kind = 'triples' | (tiles at: 1) isSpecial		ifTrue: [ self acceptsTripleWith: accepts ].	kind isNil &amp; (tiles at: 1) isSpecial not		ifTrue: [ self acceptsRunWith: accepts ].	^ MJHand with: accepts</code>    </span> is rather bad.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p><code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsTiles</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsTiles	| accepts |	tiles isEmpty ifTrue: [ ^ MJHand allTiles ].	accepts := OrderedCollection empty.	kind = 'run' ifTrue: [ self acceptsRunWith: accepts ].	kind = 'triples' | (tiles at: 1) isSpecial		ifTrue: [ self acceptsTripleWith: accepts ].	kind isNil &amp; (tiles at: 1) isSpecial not		ifTrue: [ self acceptsRunWith: accepts ].	^ MJHand with: accepts</code>    </span> is composed of <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsTripleWith:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsTripleWith: accepts	accepts addLast: (tiles at: 1) shallowCopy</code>    </span> and <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsRunWith:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsRunWith: accepts	1		to: 9		do: [ :i | 			| new |			new := (tiles at: 1) number: i.			(self accepts: new) ifTrue: [ accepts addLast: new ] ]</code>    </span>.   </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p><code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsTripleWith:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsTripleWith: accepts	accepts addLast: (tiles at: 1) shallowCopy</code>    </span>is fairly good, just copying the object at position 1.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>However <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#acceptsRunWith:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsRunWith: accepts	1		to: 9		do: [ :i | 			| new |			new := (tiles at: 1) number: i.			(self accepts: new) ifTrue: [ accepts addLast: new ] ]</code>    </span> is rather poor, as instead of tyring to figure out what tiles are missing intelligently, it scatter shots a generation of all the tiles 1 to 9 in the suit and relies on <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#accepts:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">accepts: tile	^ (tiles allSatisfy: [ :aTile | self predicate value: aTile value: tile ])		or: [ tiles isEmpty ]</code>    </span> to filter out results.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The optimization section ends up making great improvements here, making all these calculations much more efficinet.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Now to continue our work we have to make a groups class <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroups	instanceVariableNames: ''	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span> class which is composed of groups  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h5> MJGroups  </h5></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>MJGroup's implementation strategy is quite simple, we simply make a list, and ask if any groups accept the new element coming in. If none do, then we simply make a new group.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We do this on a first acceptance basis, thus with the permutation technique this will add it to the expected group.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The main methods we have to make for this are:  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#add:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">add: tile	^ tiles		detect: [ :obj | obj accepts: tile ]		ifOne: [ :obj | obj add: tile ]		ifNone: [ tiles addLast: (MJGroup new add: tile) ]</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#with:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">with: aCollection	| instance |	instance := self new.	aCollection do: [ :tile | instance add: tile ].	^ instance</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#accepts</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">accepts	| set |	set := OrderedCollection new.	tiles do: [ :group | group acceptsTiles tiles do: [ :tile | set add: tile ] ].	^ (MJHand with: set) unique</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>I've had to make other methods in other classes as well such as  <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJTiles>>#sort</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">sort	tiles := tiles asSortedCollection: [ :a :b | a valueSort &lt; b valueSort ].	^ self</code>    </span> and  <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJTiles>>#unique</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">unique	| set |	set := PluggableSet new.	set equalBlock: [ :a :b | a sameAs: b ].	set hashBlock: [ :ele | ele uniqueHash ].	tiles do: [ :tile | set add: tile ].	tiles := set asSortedCollection: [ :a :b | a valueSort &lt; b valueSort ].	self sort.	^ self</code>    </span> which themselves needed to make some methods, but overall this just enhances the <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJTiles</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles class	instanceVariableNames: ''</code>    </span> even further  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Something important we should note is calculating equality, <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJNumber>>#valueSort</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">valueSort	'man' = suit ifTrue: [ ^ 100 + self number ].	'pin' = suit ifTrue: [ ^ 200 + self number ].	'zhu' = suit ifTrue: [ ^ 300 + self number ]</code>    </span> and <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJFace>>#valueSort</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">valueSort	'east' = name ifTrue: [ ^ 401 ].	'south' = name ifTrue: [ ^ 402 ].	'west' = name ifTrue: [ ^ 403 ].	'north' = name ifTrue: [ ^ 404 ].	'white' = name ifTrue: [ ^ 405 ].	'green' = name ifTrue: [ ^ 406 ].	'red' = name ifTrue: [ ^ 407 ].</code>    </span> use offsets of powers of 2 to calculate equality. In fact each value is shifted to the left 8 fold so 345p 555m can't be confused with 555p 345p when doing equality.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We shift the number by <code>2^(n * 8)</code> each time because <code>2^n * 14 * 9 &lt; 2^(8 + n)</code>. Which is greater than the maximum number the points can effectively achieve.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Likewise I've had to make some view:  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#naturalLayout:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">naturalLayout: view	view nodes		shape: [ :each | each asBlElement padding: (BlInsets all: 15) ];		with: tiles.	^ view</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#visualizeAccepts:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">visualizeAccepts: view	tiles do: [ :group | group visualizeAccepts: view ].	^ view</code>    </span>  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#visualizeAcceptsView:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">visualizeAcceptsView: aView	&lt;gtView>	^ aView mondrian		title: 'Accepts';		painting: [ :view | self visualizeAccepts: view ]</code>    </span>  </p></div><div>  <div class="snippet textual-snippet code-snippet pharo-snippet fullWidth">    <pre class="no_bottom_margin">simpleGroups	&lt;gtExample>	^ (MJGroups with: '12246799p' asMJHand tiles)    </pre>  </div>  <figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbr8hrr9otwpw7s80466ow.png"/>  </figure></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Most of the time working on this class was mainly making utility functions in other classes that lacked them.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h5> Finishing the initial algorithm and getting a view on hands!  </h5></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Now that we have all the classes we need out of the way let us revist our first lines  </p></div><div class="snippet textual-snippet code-snippet pharo-snippet fullWidth">  <pre class="no_bottom_margin">groups := permutations collect: [ :hand | MJGroups with: hand ].acceptHands := groups collect: [ :group | group accepts ].ordered := OrderedCollection new.acceptHands do: [ :hand | ordered addAll: hand tiles ].wanted := (MJHand with: ordered) unique  </pre></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>All this logic is fairly generic, so we can just lift it to be a method!  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We can find the method here <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJHand>>#accepts</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">accepts	| permutations groups acceptHands ordered |	permutations := Array			streamContents: [ :stream | tiles permutationsDo: [ :each | stream nextPut: each copy ] ].	groups := permutations collect: [ :hand | MJGroups with: hand ].	acceptHands := groups collect: [ :group | group accepts ].	ordered := OrderedCollection new.	acceptHands do: [ :hand | ordered addAll: hand tiles ].	^ (MJHand with: ordered) unique</code>    </span> further I've made a version that filters for complete hands as well <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJHand>>#acceptsComplete</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">acceptsComplete	| permutations groups acceptHands ordered |	permutations := Array			streamContents: [ :stream | tiles permutationsDo: [ :each | stream nextPut: each copy ] ].	groups := permutations collect: [ :hand | MJGroups with: hand ].	acceptHands := groups collect: [ :group | group acceptsComplete ].	ordered := OrderedCollection new.	acceptHands do: [ :hand | ordered addAll: hand tiles ].	^ (MJHand with: ordered) unique</code>    </span> . The bulk of the complete logic is just a further filter on the groups class itsef.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Finally we can now make a view for Tiles that shows off this nice graphing  </p></div><div></div><div></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>With this view and generator, my initial problem of figuring out hand accepts is done.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>This algorithm and presentation can be used in other articles written in this book.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Sadly even with these the edgecase of <code>123456789m</code> would still be slow  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h5> Optimizing our algorithm  </h5></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>We sadly can't fully stop here, as this algorithm  gets quite slow when dealing with 8 or more tiles. This is because we are doing n! worth of work, and <code>smalltalk</code> is not the fastest of languages.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>There are two general approaches to fix the slowdown:  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>1. Fix the computational inefficiencies in the individual methods  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>2. Fix the algorithmic complexity  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Normally I'd only worry about <code>2.</code>, as getting rid of <code>n!</code> worth of work into a more manageable amount would make the overhead of <code>1.</code> unnoticeable. With that said, I am noticing a delay in computation with only <code>8!</code> (40,320~) worth of work.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>This means that the small computational inefficiencies of some methods are becoming bottle necks and are something we should investigate.   </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h6> Small computational inefficiencies  </h6></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>A quick call to <code>profile</code> over just run in the GT/Pharo environment gives me:  </p></div><figure class="snippet picture-snippet fullWidth"><img class="picture-snippet-image" src="gt-figures/8lhpbrc1tn1smhakp1fysywlp.png"/><figcaption class="picture-snippet-caption">Profile</figcaption></figure><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Here we can see that 27% of the time, we are stuck in adding to a set. Looking further 18% (or 66.2% of the 27%) is our slow <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJTiles>>#valueSort</code> . However the other 67% of the time we are stuck in the <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroups>>#add:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">add: tile	^ tiles		detect: [ :obj | obj accepts: tile ]		ifOne: [ :obj | obj add: tile ]		ifNone: [ tiles addLast: (MJGroup new add: tile) ]</code>    </span>.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The expensive part is namely in the predicate itself and even in adding an element.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h7> Optimizing <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroup	instanceVariableNames: 'kind'	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span>  </h7></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>With this information at hand let us optimize how <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroup	instanceVariableNames: 'kind'	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span> determines acceptance.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The previous section on the group itself described how it worked, let us see if we can use more information to better tackle problem.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>A key property that we can notice is that there are not that many ways a <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">MJTiles subclass: #MJGroup	instanceVariableNames: 'kind'	classVariableNames: ''	package: 'MiscGTScripts'</code>    </span> accepts a new tile. Namely 3,5 will always accept 4, 23 always accepts 1 and 4 etc etc. Since there are only 9 different tiles we can cache these and simply look it up on demand.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>So to check acceptance we only need to do 2 checks. We need to check that the <code>kind</code>'s are the same, and we need to lookup the cache, and see if the number appears in the given back set.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Further we should save the kind/suit of the coming in tile, so we don't have to access into the array to check for that releveant information.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>Further while we are tuning the performance <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroup>>#accepts:</code>    <span class="textual-snippet code-snippet pharo-method-snippet expandable-annotation-view collapsed-annotation-view"><code class="">accepts: tile	^ (tiles allSatisfy: [ :aTile | self predicate value: aTile value: tile ])		or: [ tiles isEmpty ]</code>    </span>, we may as well fixup the minor slowdown in the kind check. The issue that our <code>kind</code>s are stored as strings like <code>'pin'</code> rather than symbols like <code>#pin</code>, which the documentation for <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">Symbol</code>    <span class="textual-snippet code-snippet pharo-class-definition expandable-annotation-view collapsed-annotation-view"><code class="">String subclass: #Symbol	instanceVariableNames: ''	classVariableNames: 'NewSymbols OneCharacterSymbols SelectorTable SymbolTable'	package: 'Collections-Strings-Base'</code>    </span> shows comparsion being about 10x faster.  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>The first step is to create the <code class="annotation annotation-label annotation-label-class annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroupCache</code>. and it's <code class="annotation annotation-label annotation-label-method annotation-label-code expandable-annotation-label annotation-sibling-is-collapsed">MJGroupCache>>#table</code>. The number of hard coded values isn't too bad it's only 63~ entries!  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>After some work we get '12345678m' speed up from 1.2 per second to 2.920 per second  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <h6> Algorithmic Inefficiencies  </h6></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p>A lot can be done to offset this slow down:  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p> <b>Sort by suits</b> -  before grabbing the permutations. This will not solve the problem in general but it can speedup some common cases  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p><b>Clump same numbers</b> before the permutation, if you only permute the position of the first versions of each run, then it should (no proof) generate out the same sets  </p></div><div class="snippet textual-snippet text-snippet paragraphWidth">  <p><b>Don't generate runs for honor tiles</b> Self explanatory  </p></div>

                        <!-- page content end -->
                    </main>
                </div>
            </div>

        </div>
    </div>

    <footer class="text-center py-5 le-footer">
        <p class="le-footer-credits">
            Powered by <a class="le-footer-link" href="https://lepiter.com">Lepiter</a> | <a class="le-footer-link" href="https://feenk.com/privacy">Privacy Policy</a>
        </p>
    </footer>

    <!-- scripts -->
    <script type="text/javascript" src="assets/vendor/jquery/js/jquery.js"></script>
    <script type="text/javascript" src="assets/vendor/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/v2/src/js/datefns.min.js"></script>
    <script type="text/javascript" src="assets/v2/src/js/highlight.pack.js"></script>
    <script type="text/javascript" src="assets/v2/src/js/lepiter-common.js"></script>
    <script type="text/javascript" src="assets/v2/src/js/lepiter-snippets.js"></script>
    <script type="text/javascript" src="assets/v2/src/js/lepiter-time.js"></script>
</body>
</html>
